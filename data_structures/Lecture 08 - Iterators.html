<html>
<head>
  <title>Lecture 08 - Iterators</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/270387 (en-US); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="458"/>
<h1>Lecture 08 - Iterators</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><ul><li>returning references to member variables from member functions</li><li>another vector operation (<font face="Courier New">pop_back</font>)</li><li>erasing items from vectors is inefficient</li><li>iterators and iterator operations</li><li>Vec iterator implementation</li><li>lists as a different sequential container class</li></ul></div><b>1.2 References and Return Values</b><div><b><br></b></div><div>reference - alias for another variable</div><div>     changing one changes the other as well</div><div>     even though the names are different</div><div><img src="Lecture 08 - Iterators_files/Image.png" type="image/png" style="cursor: default;"/></div><div>in example, a and c are changed together</div><div><br></div><div>same thing occurs with reference parameters to functions and the return values of functions</div><div>when calling an accessor:</div><div>     passing the result as reference allows it to be edited</div><div>     need to make sure const is included at the end of the function declaration</div><div>     this passes the variable as <b>const reference</b> - cannot be changed</div><div><br></div><div><b>1.3 Another vector operation: pop_back</b></div><div><b><br></b></div><div><font face="Courier New">pop_back()</font> - removes the last value of the vector, reducing the size by 1</div><div><br></div><div><font face="Courier New">front(), back()</font> - denote and provide access to the first and last item in the vector</div><div>     allows for them to be changed</div><div><br></div><div><img src="Lecture 08 - Iterators_files/Image [1].png" type="image/png" style="cursor: default;"/></div><div><br></div><div><b>1.6 What To Do About the Expense of Erasing From a Vector?</b></div><div><b><br></b></div><div>vectors are not a good choice when items are continually being inserted and removed</div><div>     needs to allocate and deallocate memory constantly</div><div><br></div><div><i>lists</i> have a &quot;linked&quot; structure that makes cost of erasing independent of the size</div><div><br></div><div><b>1.7 Iterators</b></div><div><b><br></b></div><div>definition:</div><div>     identifies a container and a specific element stored in the container</div><div>     lets us examine (and change, except for const iterators) the value stored at that element of the container</div><div>     provides operations for moving between elements in the container</div><div>     restricts the available operations in ways that correspond to what the container can handle efficiently</div><div><br></div><div>iterators for different classes have many operations in common</div><div>     allows easy changing between container classes, from programmer's standpoint</div><div><br></div><div>in many ways iterators are generalizations of pointers:</div><div>     many operators/operations defined for pointers are also defined for iterators</div><div><br></div><div><b>1.8 Iterator Declarations and Operations</b></div><div><b><br></b></div><div>iterator types are declared by the container class</div><div><br></div><div><font face="Courier New">vector&lt;string&gt;::iterator p;</font></div><div><font face="Courier New">vector&lt;string&gt;::const_iterator q;</font></div><div><font face="Courier New">p = enrolled.begin();</font></div><div><font face="Courier New">*p = &quot;012312&quot;;</font></div><div><font face="Courier New"><br></font></div><div>two uninitialized iterator variables are declared</div><div>p is set to the beginning of the vector and is changed</div><div><br></div><div>dereference operator(*) is used to access the value stored at an element of the container</div><div>     can also be combined with dot operator (from classes) to access member variables and member functions</div><div><br></div><div><font face="Courier New">vector&lt;Student&gt;::iterator i = students.begin();</font></div><div><font face="Courier New">(*i).compute_averages(0.45);</font></div><div><font face="Courier New">i-&gt;compute_averages(0.45);</font></div><div><font face="Courier New"><br></font></div><div>the last two lines do the same thing - (-&gt;) makes it easier to read</div><div><br></div><div>iterators can be incremented and decremented using ++ and -- operators</div><div>     can be compared using == and !=</div><div>     can be assigned, just like any other variable</div><div><br></div><div><b>for vector iterators:</b></div><div>     integers can be added to them or subtracted from them</div><div>          <font face="Courier New">enrolled.erase(enrolled.begin() + 5);</font></div><div>     iterators may be compared using &lt;, &lt;=, etc.</div><div>     vectors are the only container class where &quot;random access&quot; iterator operations are legal</div><div><br></div><div><b>1.10 Implementing Vec&lt;T&gt; Iterators</b></div><div><b><br></b></div><div><img src="Lecture 08 - Iterators_files/Image [2].png" type="image/png" style="cursor: default;"/></div><div><br></div><div><font face="Courier New">typedef</font> statements create custom, alternate names for existing types</div><div>     T* and iterator may be used interchangeably for a vector</div><div>     iterators for other containers are much more involved</div><div><br></div><div><font face="Courier New">begin()</font> returns a pointer to the first slot in the m_data array</div><div>     <font face="Courier New">end()</font> returns a pointer to the slot just beyond the last legal element in the m_data array</div><div><br></div><div><b>1.11 A new datatype: <font face="Courier New">list</font></b></div><div><font face="Courier New"><br></font></div><div>formed as a sequentially linked structure instead of the array-like, random access/indexing structure of vectors</div><div><br></div><div><img src="Lecture 08 - Iterators_files/Image [3].png" type="image/png" style="cursor: default;"/></div><div><br></div><div><font face="Courier New">push_front</font> and <font face="Courier New">pop_front</font> functions are defined</div><div><font face="Courier New">erase</font> is very efficient for a list, independent of the size of the list</div><div><br></div><div>can't use standard <font face="Courier New">sort</font> function</div><div>     must use a special <font face="Courier New">sort</font> defined by the list type</div><div><br></div><div>no subscripting operation (do not allow &quot;random-access&quot;)</div><div><br></div><div><b>1.13 Looking Ahead</b></div><div><br></div><div>although interface of lists and vectors and iterators are similar, their implementations are very different</div><div><ul><li>no indexing in lists</li><li>no <font face="Courier New">push_front</font> or <font face="Courier New">pop_front</font> in vectors</li><li><font face="Courier New">erase</font> invalidates all iterators after the point of erasure in vectors</li><li><font face="Courier New">push_back</font> and <font face="Courier New">resize</font> invalidate all iterators in a vector</li><li style="list-style: none; display: inline"><ul><li>value of any associated vector iterator must be reassigned after these</li></ul></li><li>lists have their own <font face="Courier New">sort</font> functions</li></ul></div><div>vectors are implemented in terms of arrays</div><div>     explains why <font face="Courier New">erase</font> is so expensive</div><div>     why <font face="Courier New">push_front</font> and <font face="Courier New">pop_front</font> are not allowed</div></div>
</div></body></html> 