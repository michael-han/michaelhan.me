<html>
<head>
  <title>Lecture 20 - Operators and Friends</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/270387 (en-US); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="335"/>
<h1>Lecture 20 - Operators and Friends</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul><li>operators as non-member functions, as member functions, and as friend functions</li></ul><div><div><b>19.1 Hash Table in STL?</b></div><div><br></div><div>STL slowly evolving to use hash tables</div><div>     can use <font face="Consolas">unordered_set </font>and <font face="Consolas">unordered_map</font></div><br></div><div><b>19.2 Our Copycat Version: A Set As a Hash Table</b></div><div><b><br></b></div><div>templated over both the key type and the hash function type</div><div><img src="Lecture 20 - Operators and Friends_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div>use separate chaining for collision resolution</div><div>     main data structure inside the class is:</div><div><br></div><div>     <font face="Consolas">std::vector&lt;std::list&lt;KeyType&gt; &gt; m_table;</font></div><div>     </div><div>uses automatic resizing when table is too full</div><div>     resize is expensive</div><div>     make sure to double the size to ensure it is rarely needed</div><div><br></div><div><b>19.3 Function Objects, a.k.a. <i>Functors</i></b></div><div><b><i><br></i></b></div><div>the hash function is implemented as an object with a function call operator</div><div><br></div><div>basic form is below:</div><div><img src="Lecture 20 - Operators and Friends_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>example of a templated function object implementing less-than comparison operation</div><div>     default third argument to <font face="Consolas">std::sort</font></div><div><br></div><div>     <img src="Lecture 20 - Operators and Friends_files/Image [2].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div>constructors of function objects can be used to specify internal data</div><div>     can then be used during computation of the function call operator</div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/Image [3].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div>x&amp;y are specified when functor is created</div><div>     accepts a single argument z that it compares against the internal data</div><div>     can be used in combination with <font face="Consolas">find_if</font></div><div><img src="Lecture 20 - Operators and Friends_files/Image [4].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><b><br></b></div><div><b>19.4 Our Hash Function Object</b></div><div><b><br></b></div><div><img src="Lecture 20 - Operators and Friends_files/Image [5].png" type="image/png" style="cursor: default;"/></div><div><br></div><div><font face="Consolas">hash_string_obj</font> is one of the template parameters to the declaration of the <font face="Consolas">ds_hashset</font></div><div><img src="Lecture 20 - Operators and Friends_files/Image [6].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>19.5 Hash Set Iterators</b></div><div><b><br></b></div><div>move through the hash table in the order of the storage locations</div><div>     doesn't go through the sorted order</div><div>     increment operators go to the next entry in the current linked list or the first entry in the next non-empty list</div><div><br></div><div>nested inside the class declaration to avoid templating the iterator over the hash function type</div><div><br></div><div>stores:</div><div>     pointer to the hash table it's associated with</div><div>     index of the current list</div><div>     iterator referencing current location in the current list</div><div><br></div><div><b>19.6 Implementing <font face="Consolas">begin()</font> and <font face="Consolas">end()</font></b></div><div><b><br></b></div><div><font face="Consolas">begin()</font>: skips over empty lists to find the first key</div><div><font face="Consolas">end()</font>: assigns an index of -1</div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/Image [7].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>19.7 Iterator Increment, Decrement, and Comparison Operators</b></div><div><b><br></b></div><div>increment must find the next key, either in the current list, or in the next non-empty list</div><div>decrement must check if the iterator in the list is at the beginning and the find the previous non-empty list and find the last entry</div><div>     not expensive because lists should be very short</div><div>comparison must accommodate that when one of the iterators is the end, the internal list iterator will not have a useful value</div><div><b><br></b></div><div><b>19.8 Insert &amp; Find</b></div><div><b><br></b></div><div>computes the hash function value and then the index location</div><div><br></div><div>if key is already there, then no changes are made</div><div>     iterator is created referencing th location of the key</div><div>     pair is returned with the iterator and <font face="Consolas">false</font></div><div><br></div><div>if key is not in the list:</div><div>     key should be inserted in the list</div><div>     pair is returned with iterator and <font face="Consolas">true</font></div><div><b><br></b></div><div><img src="Lecture 20 - Operators and Friends_files/Image [8].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><b><br></b></div><div><b>19.9 Erase</b></div><div><b><br></b></div><div>two versions are implemented, one based on a key, another on an iterator</div><div><b><br></b></div><div><b>19.10 Resize</b></div><div><b><br></b></div><div>must copy the contents into a scratch, resize current vector, and reinsert each key</div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/ScreenClip.png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><b><br></b></div><div><b>19.11 Hash Table Iterator Invalidation</b></div><div><b><br></b></div><div>any insert operation invalidates all iterators</div><div>     insert could cause a resize of the table</div><div><br></div><div><b>20.12 Complex Numbers - A Brief Review</b></div><div><b><br></b></div><div>take the form <b>z = a+bi </b></div><div>     i = sqrt(-1)</div><div>     a is the real part</div><div>     b is the imaginary part</div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/Image [9].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>20.13 <font face="Consolas">Complex</font> Class declaration (<font face="Consolas">complex.h</font>)</b></div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/Image [10].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>20.14 Implementation of <font face="Consolas">Complex</font> Class (<font face="Consolas">complex.cpp</font>)</b></div><div><b><br></b></div><div><img src="Lecture 20 - Operators and Friends_files/Image [11].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><b><br></b></div><div><b>20.15 Operators as Non-Member Function and as Member Functions</b></div><div><b><br></b></div><div>have already written our own operators to store objects stored in STL containers</div><div><br></div><div>we can write them as non-member functions</div><div>     when implemented as non-member:</div><div>          <font face="Consolas">z - w</font> is translated into the function call <font face="Consolas">operator- (z,w)</font></div><div>     </div><div>     when implemented as a member:</div><div>          <font face="Consolas">z + w</font> is translated to <font face="Consolas">z.operator+ (w)</font></div><div><br></div><div>shows that operator+ is a member function of z</div><div>     since z appears on the left hand side of the operator</div><div><br></div><div>     it is within the scope of class <font face="Consolas">Complex</font>, so private member variables can be accessed directly</div><div>     member variables of z are referenced by name directly</div><div>     member variables of w are accessed through parameter rhs</div><div>     member function is const: z will not be changed</div><div><br></div><div><b>20.16 Assignment Operators</b></div><div><b><br></b></div><div>assignment operator: <font face="Consolas">z1 = z2</font> becomes a function call: <font face="Consolas">z1.operator=(z2)</font></div><div>argument is passed by constant reference</div><div>     its values are used to change the contents of the left side of the operator</div><div>     reference to this object is returned - allowing subsequent calls (cascaded)</div><div><br></div><div>the fact that operator= returns a reference allows us to write code of the form: <font face="Consolas">(z1 = z2).real()</font></div><div><br></div><div><b>20.17 Exercise</b></div><div><br></div><div>write an operator+= as a member function of the <font face="Consolas">Complex</font> class</div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/Image [12].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>20.18 Returning Objects vs. Returning References to Objects</b></div><div><b><br></b></div><div>in the <font face="Calibri">operator+</font> and <font face="Consolas">operator-</font> functions we create new <font face="Consolas">Complex</font> objects and return the new objects</div><div>     technically, we don't return the new object</div><div>     return a copy of the object</div><div><br></div><div>important that the copy constructor is correctly implemented</div><div><b><br></b></div><div>when you change an existing object inside an operator and need to return that object</div><div>     must return a reference to that object</div><div>     this is why return types of <font face="Consolas">operator=</font> and <font face="Consolas">operator+=</font> are both <font face="Consolas">Complex&amp;</font></div><div><b><br></b></div><div>common error is attempting to return a reference to a locally created object</div><div>     results in someone having a pointer to stale memory</div><div>     may behave correctly for a short while until memory under the pointer is allocated by someone else</div><div><b><br></b></div><div><b>20.19 Friend Classes vs Friend Functions</b></div><div><b><br></b></div><div>in example:</div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/Image [13].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div><div>Foo class has designated Bar to be a friend</div><div>must be done in the <font face="Consolas">public</font> area of the declaration of Foo</div><div><br></div><div>allows member functions in class Bar to access all of the private member functions and variables of Foo</div><div>     as if they were public (but not vice versa)</div><div>note that Foo is giving friendship, rather than Bar claiming it</div><div><br></div><div>alternatively, within definition of class</div><div>     we can designate specific functions to be <font face="Consolas">&quot;friend&quot;s</font> </div><div>     grants these functions access similar to that of a member function</div><div>     common example of this is operators (stream operators)</div><div><br></div><div><b>20.20 Stream Operators as Friend Functions</b></div><div><b><br></b></div><div>operators &gt;&gt; and &lt;&lt; are defined for <font face="Consolas">Complex</font> class</div><div><br></div><div><img src="Lecture 20 - Operators and Friends_files/Image [14].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div><div>compiler translates: <font face="Consolas">cout &lt;&lt; z3</font> to <font face="Consolas">operator&lt;&lt; (cout, z3)</font></div><div>each application returns an <font face="Consolas">ostream</font> object so that the next application can occur</div><div><br></div><div>if we wanted to make one of these a regular member function,</div><div>     it would have to be a member function of the <font face="Consolas">ostream</font> class (it is the first argument)</div><div>     can never make it a member function of the <font face="Consolas">Complex</font> class</div><div><br></div><div>this is why stream operators are never member functions</div><div>     either ordinary non-member functions</div><div>          if the operators can do their work through the public class interface</div><div>     for friend functions</div><div>          if they need non-public access</div><div><br></div><div><b>20.21 Summary of Operator Overloading in C++</b></div><div><b><br></b></div><div><img src="Lecture 20 - Operators and Friends_files/Image [15].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div><div>can't create new operators</div><div>can't change the number of arguments (except for function call operator - has variable amount of arguments)</div><div><br></div><div>three different ways to overload an operator</div><div>when there is a choice, we recommend trying to write operators in this order:</div><div><ol><li>     non-member function</li><li>     member function</li><li>     friend function</li></ol></div><div>most important rule is to <b>never change the intuitive meaning of the operator</b></div><div>     whole point of operators is lost if you do</div></div>
</div></body></html> 