<html>
<head>
  <title>Lecture 21 - Priority Queues and Leftist Heaps</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/270387 (en-US); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="469"/>
<h1>Lecture 21 - Priority Queues and Leftist Heaps</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul><li>STL Queues and Stacks</li><li>What's a priority queue?</li><li>A Priority Queue as a Heap, <font face="Consolas">percolate_up</font> and <font face="Consolas">percolate_down</font></li><li>A Heap as a Vector, Building a Heap, Heap Sort</li><li>Merging heaps are the motivation for <i>leftist heaps</i></li></ul><div><b>21.1 Additional STL Container Classes: Stacks and Queues</b></div><div><b><br></b></div><div>one way to obtain computational efficiency is to consider a simplified set of operations</div><div>     not particularly necessary for all assignments</div><div>     vector and list can mimic functionalities</div><div><br></div><div><b>stacks</b> - allow access, insertion and deletion from only one end called the <i>top</i></div><div>     no access to values in the middle of a stack</div><div>     may be implemented efficiently in terms of vectors and lists</div><div>          vectors are preferred</div><div>          don't need to store memory for the next node</div><div>     all operations are O(1)</div><div><br></div><div><b>queues</b> - allow insertion at one end, called the <i>back</i> and removal from the other end, called the <i>front</i></div><div>     no access to values in the middle of a queue</div><div>     may be implemented efficiently in terms of a list</div><div>          uses <font face="Consolas">push_back</font> and <font face="Consolas">pop_front</font></div><div>     using vectors is also possible, but requires more work to get it right</div><div>     all operations are O(1)</div><div><b><br></b></div><div><b>21.2 What's a Priority Queue?</b></div><div><b><br></b></div><div>used in prioritizing operations</div><div>     to-do list, jobs on a shop floor, packet routing in a network</div><div><br></div><div>interface is most similar to a queue</div><div>     idea of a <font face="Consolas">front</font> or <font face="Consolas">top</font> and a <font face="Consolas">tail</font> or a <font face="Consolas">back</font></div><div><font face="Consolas"><br></font></div><div>each item is stored with an associated &quot;priority&quot;</div><div>     top item is the one with the lowest value of the priority score</div><div>     tail or back is never accessed through public interface</div><div><br></div><div>main operations are <font face="Consolas">insert</font> or <font face="Consolas">push</font> and <font face="Consolas">pop</font></div><div><b><br></b></div><div><b>21.3 Some Data Structure Options for Implementing a Priority Queue</b></div><div><b><br></b></div><div>vector or list, either sorted or unsorted</div><div>     at least one of the operations will cost linear time</div><div>     if we think of container as a linear structure</div><div><br></div><div>binary search trees</div><div>     if we use priority as a key</div><div>     can use combination of finding minimum key</div><div>     erase to implement pop</div><div>     costs logarithmic time for all operations</div><div><br></div><div>latter is better, but we would like to improve upon it</div><div>     might be more natural if minimum priority value were stored at the root</div><div><br></div><div>can be achieved using a binary <i>heap</i></div><div>     gives up complete ordering imposed in binary search tree</div><div><br></div><div><b>21.4 Definition: Binary Heaps</b></div><div><b><br></b></div><div>complete binary tree</div><div>     at each internal node, p, the value stored is less than the value stored at either of p's children</div><div><br></div><div>     complete binary tree is one that is completely filled, except perhaps at the lowest level</div><div>          at the lowest level all leaf nodes are as far to the left as possible</div><div><br></div><div>binary heaps will be drawn as binary trees but implemented using vectors</div><div><br></div><div>could also be organized the other way around, node is greater than the values at its children</div><div><br></div><div><b>21.6 Implementing Pop (a.k.a. Delete Min)</b></div><div><b><br></b></div><div>top (root) of the tree is removed</div><div><br></div><div>replaced by the value stored in the last leaf node</div><div>     has echoes of the erase function in binary search trees</div><div>     have not yet discussed how to find the last leaf</div><div><br></div><div>last leaf node is removed</div><div><br></div><div><font face="Consolas">percolate_down</font> function is then run to restore the heap property</div><div>     written in terms of the tree nodes with child pointers</div><div>     later it will be written in terms of vector subscripts</div><div><br></div><div><img src="Lecture 21 - Priority Queues and Leftist Heap_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>21.7 Push/Insert</b></div><div><b><br></b></div><div>to add a value to heap, new last leaf node is created</div><div>     then the following <font face="Consolas">percolate_up</font> function is run</div><div>     assumes each node has a pointer to its parent</div><div><br></div><div><img src="Lecture 21 - Priority Queues and Leftist Heap_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>21.8 Analysis</b></div><div><b><br></b></div><div>both <font face="Consolas">percolate_down</font> and <font face="Consolas">percolate_up</font> are O(log <i>n</i>) in the worst case</div><div>     just need to up a narrow path up the height</div><div><br></div><div><font face="Consolas">percolate_up</font> can be O(1) in the average case</div><div><br></div><div><b>21.10 Vector Implementation</b></div><div><b><br></b></div><div>tree is never explicitly constructed</div><div>     heap is stored as a vector</div><div>     child and parent pointers can be implicitly calculated</div><div><br></div><div>number the nodes in the tree starting with 0 first by level</div><div>     the scanning across each row</div><div><br></div><div>     these are the vector indices</div><div><br></div><div><img src="Lecture 21 - Priority Queues and Leftist Heap_files/Image [2].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div>standard library <font face="Consolas">priority_queue</font> is implemented as a binary heap</div><div><br></div><div><b>21.13 Building a Heap</b></div><div><br></div><div>in order to build a heap from a vector of values, for each index from [(n-1)/2] down to 0, run <font face="Consolas">percolate_down</font></div><div>     requires at most O(n) operations</div><div><br></div><div>if we ran <font face="Consolas">percolate_up</font> from each index starting at n-1 down to 0, we would incur a O(n logn) cost</div><div><br></div><div><b>21.14 Heap Sort</b></div><div><b><br></b></div><div>simple algorithm to sort a vector of values</div><div>     build a heap</div><div>     run n consecutive pop operations, storing each popped value in a new vector</div><div><br></div><div>requires O(n logn) time</div><div><br></div><div><b>21.15 Summary</b></div><div><b><br></b></div><div>priority queues are conceptually similar to queues</div><div>     order in which values and entries are removed depends on a priority</div><div><br></div><div>heaps, which are conceptually a binary tree but are implemented in a vector</div><div>     are the data structure of choice for a priority queue</div><div><br></div><div>priority of an entry may change while the entry is in the queue</div><div>     have not discussed this</div><div>     </div><div><b>21.16 Leftist Heaps - Overview</b></div><div><br></div><div>goal is to be able to merge two heaps in O(logn) time</div><div>     where n is the number of values stored in the larger of the two heaps</div><div>     merging two binary heaps (where every row but the last is full) requres O(n)</div><div><br></div><div>binary trees where we deliberately attempt to eliminate any balance</div><div>     essentially a sorted linked list</div><div><br></div><div>implemented explicitly as trees rather than vectors</div><div><br></div><div><b>21.17 Leftist Heaps - Mathematical Background</b></div><div><b><br></b></div><div><i>null path length</i> of a tree node is the length of the shortest path to a node with 0 or 1 child</div><div><i>leftist tree</i> is a binary tree where at each node, the NPL of the left child is greater than or equal to the NPL of the right child</div><div><i>right path</i> is obtained by following right children until a NULL child is reached</div><div><br></div><div><b>theorem:</b>  a leftist tree with r&gt;0 nodes on its right path has at least 2^r-1 nodes</div><div>     proven by induction on r</div><div><br></div><div><b>corollary:</b> leftist tree with n nodes has a right path length of at most log(n+1) = O(logn) nodes</div><div><br></div><div><b>21.18 Leftist Heap Operations</b></div><div><b><br></b></div><div>the <font face="Consolas">insert</font> and <font face="Consolas">delete_min</font> operations will depend on the <font face="Consolas">merge</font> operation</div><div><br></div><div>fundamental idea of <font face="Consolas">merge</font>:</div><div>     given two leftist heaps with h1 and h2 pointers to their roots</div><div>     suppose <font face="Consolas">h1-&gt;value &lt;= h2-&gt;value</font></div><div>     recursively merge <font face="Consolas">h1-&gt;right</font> with <font face="Consolas">h2</font>, making the resulting heap <font face="Consolas">h1-&gt;right</font></div><div><br></div><div>when leftist property is violated at a tree node involved in the merge</div><div>     left and right children are swapped</div><div>     guarantees leftist property of the resulting tree</div><div><br></div><div>requires O(logn + logm) time where m and n are the numbers of nodes stored in the two heaps</div><div><br></div><div><b>21.19 Merge Code</b></div><div><b><br></b></div><div><img src="Lecture 21 - Priority Queues and Leftist Heap_files/Image [3].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div><div><img src="Lecture 21 - Priority Queues and Leftist Heap_files/Image [4].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div></div>
</div></body></html> 