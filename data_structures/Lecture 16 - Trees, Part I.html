<html>
<head>
  <title>Lecture 16 - Trees, Part I</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/270387 (en-US); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="402"/>
<h1>Lecture 16 - Trees, Part I</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul><li>STL set container class (like a map, but without the pairs)</li><li>implementation of <font face="Courier New">ds_set</font> using binary search trees</li><li>in-order, pre-order, and post-order traversal</li><li>breadth-first and depth-first tree search</li></ul><div><b>16.1 Standard Library Sets</b></div><div><b><br></b></div><div>sets are <i>ordered</i> containers storing unique &quot;keys&quot;</div><div>     ordering defaults to <font face="Courier New">operator&lt;</font></div><div>     technically not traditional mathematical sets</div><div><br></div><div>sets are like maps, but only have keys</div><div>     keys are constant</div><div>     need to remove, change, and then reinsert it into the set</div><div><br></div><div>access to items in sets is extremely fast (O(log<i>n</i>))</div><div>     just like maps</div><div><br></div><div>sets have the usual constructors as well as the size member function</div><div><br></div><div><b>16.2 Set Iterators</b></div><div><b><br></b></div><div>set iterators are bidirectional</div><div>     allow you to step forward and backward (++, --)</div><div>     <font face="Courier New">begin()</font> and <font face="Courier New">end()</font> delimit bounds of the set</div><div><img src="Lecture 16 - Trees, Part I_files/Image.png" type="image/png" height="57" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="647"/></div><div><br></div><div><b>16.3 Set <font face="Courier New">insert</font></b></div><div><b><br></b></div><div>two different versions of the insert member function</div><div><br></div><div>first: inserts the entry into the set and returns a pair</div><div>     first component refers to the location in the set</div><div>     second component is true if the entry wasn't already in the set</div><div><br></div><div>second: also inserts the key if it isn't already there</div><div>     iterator <font face="Courier New">pos</font> is a &quot;hint&quot; as to where to put it</div><div>     runs in constant time if &quot;hint&quot; is good<br></div><div><br></div><div><img src="Lecture 16 - Trees, Part I_files/Image [1].png" type="image/png" height="54" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="565"/></div><div><br></div><div><b>16.4 Set <font face="Courier New">erase</font></b></div><div><b><br></b></div><div>there are 3 versions of erase</div><div><br></div><div>first: returns the number of entries removed</div><div><br></div><div>second and third: just like the corresponding erase functions for maps</div><div>    don't return iterators (unlike list and vector erase)</div><div><br></div><div><img src="Lecture 16 - Trees, Part I_files/Image [2].png" type="image/png" height="73" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="510"/></div><div><br></div><div><b>16.5 Set <font face="Courier New">find</font></b></div><div><b><br></b></div><div>find returns the <font face="Courier New">end</font> iterator if the key is not in the set</div><div><br></div><div><img src="Lecture 16 - Trees, Part I_files/Image [3].png" type="image/png" height="28" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="505"/></div><div><br></div><div><b>16.6 Beginning our implementation of <font face="Courier New">ds_set</font>: The Tree Node Class</b></div><div><br></div><div>class definition for nodes in the tree:</div><div><br></div><div><img src="Lecture 16 - Trees, Part I_files/Image [4].png" type="image/png" height="149" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="598"/></div><div><br></div><div>sometimes a third pointer is added</div><div>     to the parent TreeNode</div><div><br></div><div><b>16.7 Exercises</b></div><div><b><br></b></div><div>1. Write a templated function to find the smallest value stored in a binary search tree</div><div>     root node is pointed to by p</div><div><br></div><div><img src="Lecture 16 - Trees, Part I_files/Image [5].png" type="image/png" height="254" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="469"/></div><div><br></div><div>2. write a function to count the number of odd numbers stored in a tree</div><div>     should accept a <font face="Courier New">TreeNode&lt;int&gt;</font> pointer as its sole argument and return an integer</div><div><br></div><div><img src="Lecture 16 - Trees, Part I_files/Image [6].png" type="image/png" height="165" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="544"/></div><div><br></div><div><b>16.8 <font face="Courier New">ds_set</font> and Binary Search Tree Implementation</b></div><div><b><br></b></div><div>partial implementation of a set using binary search tree is in code attached (ds_set.h)</div><div><br></div><div>increment and decrement operations for iterators have been omitted from this implementation</div><div><br></div><div><b>16.9 <font face="Courier New">ds_set</font>: Class Overview</b></div><div><br></div><div>there is only two auxiliary classes, <font face="Courier New">TreeNode</font> and <font face="Courier New">tree_iterator</font></div><div>     all three are templated</div><div><br></div><div>only member variables of <font face="Courier New">ds_set</font> are the root and the size</div><div><br></div><div>iterator class is declared internally</div><div>     <font face="Courier New">operator*</font> returns a const reference (keys cannot change)</div><div><br></div><div>public member functions just call a private member function that does all of the work</div><div>copy constructor, <font face="Courier New">operator=</font>, and destructor must be provided because the class stores and manages dynamically allocated memory</div><div><br></div><div><b>16.10 Exercises</b></div><div><b><br></b></div><div>1. provide the implementation of the member function of <font face="Courier New">ds_set&lt;T&gt;::begin</font></div><div>     problem of finding the node in the tree that stores the smallest value</div><div><br></div><div><img src="Lecture 16 - Trees, Part I_files/Image [7].png" type="image/png" height="133" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="429"/></div><div><br></div><div>2. write a recursive version of the function <font face="Courier New">find</font></div><div><img src="Lecture 16 - Trees, Part I_files/Image [8].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>16.11 In-order, Pre-order, Post-Order Traversal</b></div><div><br></div><div>three general orders in which binary trees are traversed:</div><div>     pre-order</div><div>     in-order</div><div>     post-order</div><div><br></div><div><b><br></b></div><div><b>16.12 Depth-First &amp; Breadth-First Search</b></div><div><br></div><div>depth-first search - greedily follow links down into the tree</div><div>     don't backtrack until we have hit a leave</div><div>     back up only to the last decision point and then proceed to the next leaf</div><div><br></div><div>     quickly investigates leaf nodes, but if it has made an &quot;incorrect decision&quot; early in the search</div><div>          it will take a long time to work back and go down the &quot;right branch&quot;</div><div><br></div><div>breadth-first search - nodes are visited with priority based on their distance from the root</div><div>     nodes closer to the root visited first</div><div>     visit the nodes by level</div><div>     </div><div>     memory intensive - must store all nodes at the current level</div><div>          this number will double (worst case) as we progress down the tree</div><div><br></div><div>both will eventually visit all elements in the tree</div><div><br></div><div>example of breadth-first traversal:</div><div>running time: O(1 + 2 + 4 + ... + n/2) =&gt; O(n)</div><div>memory usage: O(n/2) =&gt; O(n)</div><div><img src="Lecture 16 - Trees, Part I_files/Image [9].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div></div>
</div></body></html> 