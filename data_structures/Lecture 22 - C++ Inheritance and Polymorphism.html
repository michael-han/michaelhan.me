<html>
<head>
  <title>Lecture 22 - C++ Inheritance and Polymorphism</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/270387 (en-US); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="300"/>
<h1>Lecture 22 - C++ Inheritance and Polymorphism</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul><li>inheritance is a relationship among classes.</li><li style="list-style: none; display: inline"><ul><li>example: bank accounts, polygons, stack &amp; list</li></ul></li><li>basic mechanisms of inheritance</li><li>types of inheritance</li><li>is-A, has-A, as-A relationships among classes</li><li>polymorphism</li></ul><div><b>22.1 Motivating Example: Bank Accounts</b></div><div><b><br></b></div><div>consider different types of accounts:</div><div>     savings</div><div>     checking</div><div>     time withdrawal</div><div><br></div><div>if you were designing classes to represent each of these</div><div>     what member functions might be repeated among different classes?</div><div>     what member functions would be unique to a given class?</div><div><br></div><div>to avoid repeating common member functions and member variables</div><div>     we will create a class hierarchy where common members are placed in a base class</div><div>     specialized members are placed in derived classes</div><div><br></div><div><b>22.2 Accounts Hierarchy</b></div><div><b><br></b></div><div><img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image.png" type="image/png" style="cursor: default;cursor: default;"/></div><div><img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [2].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><b><br></b></div><div><font face="Consolas">Account</font> is the base class of the hierarchy</div><div><font face="Consolas">SavingsAccount</font> is a derived class from Account</div><div><br></div><div>member variable <font face="Consolas">balance</font> in base class <font face="Consolas">Account</font> is <font face="Consolas">protected</font>:</div><div>     balance is not publicly accessible outside the class</div><div>     accessible in the derived classes</div><div>     if it was <font face="Consolas">private</font>, <font face="Consolas">SavingsAccount</font> member functions could not access</div><div><br></div><div>when using objects of type SavingsAccount</div><div>     the inherited and derived members are treated exactly the same</div><div>     are not distinguishable</div><div><br></div><div><font face="Consolas">CheckingAccount</font> is also a derived from base class <font face="Consolas">Account</font></div><div><br><font face="Consolas">TimeAccount</font> is derived from <font face="Consolas">SavingsAccount</font></div><div><b><br></b></div><div><b>22.4 Constructors and Destructors</b></div><div><br></div><div>constructors of a derived class call base class constructor immediately before anything else</div><div>     only thing you can control is which constructor is called and what arguments will be</div><div><br></div><div>reverse is true for destructors:</div><div>     derived class constructors do their jobs first, then base class destructors</div><div>     destructors for classes which have derived classes must be marked <i>virtual</i> for this chain of calls to happen</div><div><br></div><div><b>22.5 Overriding Member Functions in Derived Classes</b></div><div><b><br></b></div><div>derived class can redefine member functions in the base class </div><div>     function prototype must be identical (const, reference, etc.)</div><div><br></div><div>if you want to call the original, you must explicitly call it <font face="Consolas">SavingsAccount::compound</font></div><div><br></div><div><b>22.6 Public, Private and Protected Inheritance</b></div><div><b><br></b></div><div>notice the line:</div><div>     <img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [3].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div>specifies that the member functions and variables from <font face="Consolas">Account</font> do not change their public, protected, or private status in <font face="Consolas">SavingsAccount</font></div><div>     called <i>public</i> inheritance</div><div><br></div><div><i>protected</i> and <i>private</i> inheritance are other options</div><div>     protected inheritance - public members becomes protected, other members are unchanged</div><div>     private inheritance - all members become private</div><div><br></div><div><b>22.7 Stack Inheriting from List</b></div><div><b><br></b></div><div>for another example of inheritance, let's re-implement <font face="Consolas">stack</font> class as derived from <font face="Consolas">std::list</font></div><div><br></div><div><img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [4].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div>private inheritance hides <font face="Consolas">std::list&lt;T&gt;</font> member functions from the outside world</div><div>     still available to <font face="Consolas">stack&lt;T&gt;</font> class</div><div><br></div><div>no member variables are defined - all of them needed are in the list class</div><div><br></div><div>when stack member function uses the same name as base class</div><div>     name of base class followed by :: must be provided to indicate which class to use</div><div><br></div><div>copy constructor just uses copy constructor of base class without any special designation</div><div><br></div><div><b>22.8 Is-A, Has-A, As-A Relationships Among Classes</b></div><div><b><br></b></div><div>when trying to determine the relationship between hypothetical classes C1 and C2:</div><div><ul><li>C1 is a C2</li><li style="list-style: none; display: inline"><ul><li>C1 should be a derived class of C2 (subclass)</li></ul></li><li>C1 has a C2</li><li style="list-style: none; display: inline"><ul><li>C1 should have a member variable of type C2</li></ul></li><li>C1 is implemented as a C2</li><li style="list-style: none; display: inline"><ul><li>C1 should be derived from C2, but with private inheritance</li></ul></li></ul><div><b>22.10 Note: Multiple Inheritance</b></div></div><div><br></div><div>when sketching a class hierarchy for geometric objects</div><div>     may have wanted to specify relationships that were more complex</div><div>     some objects may inherit from more than one class</div><div><br></div><div>this is called multiple inheritance</div><div><br></div><div><b>22.11 Introduction to Polymorphism</b></div><div><b><br></b></div><div><img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [5].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div><div>functions that are common, at least have a common interface, are in <font face="Consolas">Polygon</font></div><div><font face="Consolas"><br></font></div><div>some of these are marked <font face="Consolas">virtual</font></div><div>     means when if they are redefined by a derived class, this new definition will be used</div><div>     even for pointers to base class objects</div><div><br></div><div>some of these <font face="Consolas">virtual</font> functions, those whose declarations are followed by = 0, are pure virtual</div><div>     means they must be redefined in the &quot;lesser&quot; classes</div><div>     anything like this is called &quot;abstract&quot;</div><div><br></div><div>     objects of abstract types may not be created, only pointers to these objects</div><div><br></div><div><b>22.12 A Polymorphic List of Polygon Objects</b></div><div><b><br></b></div><div>instead of two separate lists of polygon objects, we can create one &quot;polymorphic&quot; list</div><div>     </div><div>     <img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [6].png" type="image/png" style="cursor: default;cursor: default;"/></div><div>objects are constructed using <font face="Consolas">new</font> and inserted into the list</div><div><br></div><div>     <img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [7].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div><div><b>22.13 Accessing Objects Through a Polymorphic List of Pointers</b></div><div><b><br></b></div><div>when summing the areas of all the polygons:</div><div><br></div><div>     <img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [8].png" type="image/png" style="cursor: default;cursor: default;"/></div><div>important to recognize which Area function is being called</div><div>     if <font face="Consolas">*i</font> is pointing to a <font face="Consolas">Triangle</font> object, then the function defined in the <font face="Consolas">Triangle</font> class would be called</div><div><br></div><div>to use a function in <font face="Consolas">Quadrilateral</font> that is not declared in <font face="Consolas">Polygon</font>, you must &quot;cast&quot; the pointer</div><div>     pointer <font face="Consolas">*q</font> will be NULL if <font face="Consolas">*i</font> is not a <font face="Consolas">Quadrilateral</font> object</div><div><br></div><div>     <img src="Lecture 22 - C++ Inheritance and Polymorphism_files/Image [9].png" type="image/png" style="cursor: default;cursor: default;"/></div></div>
</div></body></html> 