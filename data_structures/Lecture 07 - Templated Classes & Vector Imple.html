<html>
<head>
  <title>Lecture 07 - Templated Classes &amp; Vector Implementation</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/270387 (en-US); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="224"/>
<h1>Lecture 07 - Templated Classes &amp; Vector Implementation</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul><li>going to implement STL containers using dynamic allocation of arrays</li></ul><div><b>1.1</b> <b>Today's Lecture</b></div><div><b><br></b></div><div>designing our own container class:</div><div>     mimic the interface of standard library containers</div><div>     study the design of memory management</div><div>     move toward designing our own, more sophisticated classes</div><div><br></div><div>vector implementation</div><div>templated classes</div><div>copy constructors, assignment operators, and destructors</div><div>     important when dealing with dynamic memory</div><div><br></div><div><b>1.2 Vector Public Interface</b></div><div><b><br></b></div><div>&quot;chunk of the header file for vectors&quot;</div><div><b><br></b></div><div><img src="Lecture 07 - Templated Classes & Vector Imple_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>to implement our own version of this class, we need to implement all these operations</div><div>templated class - meaning we don't necessarily know what will be stored in the container</div><div>     will accept a variety of types in it</div><div><br></div><div><b>1.3 Templated Class Declarations and Member Function Definitions</b></div><div><b><br></b></div><div>in terms of the layout in vec.h:</div><div>     templated class</div><div>     keyword <font face="Courier New">template</font> and template type name must appear before class declaration</div><div>          </div><div>          <span style="font-family: 'Courier New';">template &lt;class T&gt; class Vec</span></div><div><br></div><div>T is used as a type</div><div>     member functions are said to be &quot;templated over type T&quot;</div><div><br></div><div>templated member functions are often defined inside the class declaration</div><div>     seems like a &quot;big violation&quot;</div><div>if it is defined outside the class declaration must be preceded with <font face="Courier New">template &lt;class T&gt;</font></div><div><br></div><div>ex. <font face="Courier New">template &lt;class T&gt; void Vec&lt;T&gt;::create...</font></div><div><br></div><div><b>1.4 Syntax and Compilation</b></div><div><b><br></b></div><div>templated classes and member functions are not created/compiled/instantiated until they are needed</div><div>     compilation of class declaration by a line of the form <font face="Courier New">Vec&lt;int&gt; v1;</font></div><div>     replaces int for T and then compiles the code dependent on T</div><div>     compiles the default constructor because it is used</div><div>          other member functions are not compiled unless they are used</div><div><br></div><div>when a different type is used with Vec, the class declaration is compiled again</div><div>     only member functions used are compiled</div><div><br></div><div>so, class declaration and code for all used member functions must be provided where they are used</div><div>     member functions are often included within or defined outside of the class declaration but still in the .h file</div><div>     can include themin  a .cpp file, but it needs to be #include-d (bad practice)</div><div><br></div><div><b>1.5 Member Variables</b></div><div><b><br></b></div><div><font face="Courier New">m_data</font> - pointer to the start of the array after it has been allocated</div><div><br></div><div><font face="Courier New">m_size</font> - indicates the number of locations currently in use in the vector</div><div>     what is returned by size()</div><div><br></div><div><font face="Courier New">m_alloc</font> - number of slots in the dynamically allocated block of memory</div><div><br></div><div><b>1.6 Typedefs</b></div><div><b><br></b></div><div>types are created through <font face="Courier New">typedef</font> statements</div><div>     names can be used as ordinary type names</div><div><b><br></b></div><div><b>1.7 operator[]</b></div><div>    </div><div>operator is translated by the compiler into a call to a function called <font face="Courier New">operator[]</font></div><div><br></div><div>two versions:</div><div>     non-const - returns a reference to <font face="Courier New">m_data[i]</font></div><div>     const - returns as a const reference</div><div>          can't be modified</div><div><br></div><div><b>1.8 Default Versions of Assignment Operator and Copy Constructor are Dangerous!</b></div><div><b><br></b></div><div>need to consider what would happen if copy constructor and assignment operator weren't written</div><div><br></div><div>default copy constructor would look like:</div><div>     <img src="Lecture 07 - Templated Classes & Vector Imple_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>what it does:</div><div>     construct each member variable form the corresponding member variable of v</div><div>     <b>dangerous</b></div><div><br></div><div>     don't want to copy just the <font face="Courier New">m_data</font> pointer</div><div>     need to create a copy of the entire array</div><div><br></div><div><b>1.10 Classes With Dynamically Allocated Memory</b></div><div><b><br></b></div><div>for classes that use dynamically-allocated memory</div><div>     each object must do its own memory allocation and deallocation</div><div>     must be careful to keep the memory of each object instance separate from all others</div><div><br></div><div>all memory should be released when the object is finished with it</div><div>     or when it goes out of scope</div><div>     use a <i>destructor</i></div><div><i><br></i></div><div>must write our own</div><div>     <i>copy constructor</i></div><div>     <i>assignment operator</i></div><div>     <i>destructor</i></div><div><i><br></i></div><div><b>1.11 Copy Constructor</b></div><div><b><br></b></div><div>must allocate any memory needed for the object being constructed</div><div>copy the contents of the passed memory to the new memory</div><div>set the values of the various member variables appropriately</div><div><br></div><div>this is implemented in vec.h</div><div><img src="Lecture 07 - Templated Classes & Vector Imple_files/Image [2].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>1.12 Aside (1): the &quot;this&quot; pointer</b></div><div><b><br></b></div><div>all class object have a special pointer defined as <font face="Courier New">this</font></div><div>     points to the current class object</div><div>     cannot be changed</div><div><br></div><div><font face="Courier New">*this</font> is a reference to the class object</div><div>     in order to get to the data itself</div><div><br></div><div>used in several ways:</div><div>     make it clear when member variables of the current object are being used</div><div>          not necessarily more inefficient - no downside</div><div>     check to see when an assignment is self-referencing</div><div>     return a reference to the current object</div><div><br></div><div><b>1.13 Aside (2): Assignment operators, generally speaking</b></div><div><b><br></b></div><div>cascaded assignment operators of the form </div><div>     <font face="Courier New">v1 = v2 = v3;</font></div><div>are translated as: </div><div>    <font face="Courier New"> v1.operator=(v2.operator=(v3));</font></div><div><font face="Courier New"><br></font></div><div>value of the assignment operator must be suitable for input to a second assignment</div><div>     result of an assignment operator ought to be a reference to an object</div><div><br></div><div><b>1.14 Assignment Operator for Vec</b></div><div><b><br></b></div><div>usually takes on the same form for every class:</div><div><br></div><div><img src="Lecture 07 - Templated Classes & Vector Imple_files/Image [3].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div>does no work if there is a self assignment</div><div><br></div><div>otherwise:</div><div>     destroy the contents of the current object</div><div>     copy the passed object</div><div>     return a reference to the copied current object, using <font face="Courier New">this</font> pointer</div><div><br></div><div><b>1.15 Destructor (the &quot;constructor with a tilde&quot;)</b></div><div><b><br></b></div><div>called implicitly when an automatically-allocated object goes out of scope</div><div>     or when a dynamically-allocated object is deleted</div><div><br></div><div>responsible for deleting the dynamic memory &quot;owned&quot; by the class</div><div><br></div><div><b>1.16 Increasing the Size of the Vec</b></div><div><b><br></b></div><div><font face="Courier New">push_back</font> adds to the end of the array</div><div>     increases <font face="Courier New">m_size</font> by one T location</div><div>     what if allocated array is full <font face="Courier New">(m_size == m_alloc)</font>?</div><div><br></div><div>1. allocate a new, larger array</div><div>     generally double the size of the current array</div><div>2. if the array size was originally 0, make sure the resulting size is at least 1</div><div>3. copy the contents of the current array</div><div>4. delete current array, make <font face="Courier New">m_data</font> pointer point to the start of the new array, change <font face="Courier New">m_size</font> and <font face="Courier New">m_alloc</font> appropriately</div><div><br></div><div>only add the new object to the back of the array if we are sure there is enough room in the array</div><div><br></div><div><img src="Lecture 07 - Templated Classes & Vector Imple_files/Image [4].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>1.19 Valgrind Memory Checker</b></div><div><b><br></b></div><div>memory debugging tool</div><div><br></div><div>use of uninitialized memory</div><div>reading/writing memory after it has been free'd</div><div>reading/writing of the malloc'd blocks</div><div>reading/writing inappropriate areas on the stack</div><div>memory leaks - where pointers to malloc'd blocks are lost forever</div><div>mismatched use of malloc/new/new[] vs free/delete/delete[]</div><div>overlapping src and dst pointers in memcpy() and related functions</div></div>
</div></body></html> 