<html>
<head>
  <title>Lecture 02 - Vectors, Recursion, and Order Notation</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/270387 (en-US); Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="477"/>
<h1>Lecture 02 - Vectors, Recursion, and Order Notation</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><b>2.1 Standard Library (STL) Vectors</b><div><b><br></b></div><div>vectors - &quot;smart arrays&quot;</div><div><b><br></b></div><div><b>2.2 STL Vectors: &quot;C++ Arrays&quot;</b></div><div><b><br></b></div><div>to hold sequences of numbers</div><div>dynamically sized - don't have to declare a size at the beginning</div><div>one dimensional</div><div><br></div><div>capabilities:</div><div>     holds objects of any type</div><div>     starts empty</div><div>     can add objects to the end - no limit on size</div><div>     can be treated like an ordinary array using the subscripting operator</div><div>     knows how many elements it stores (unlike C-style array)</div><div>     no automatic checking of subscript bounds (selecting index that is too big</div><div><br></div><div>to create a vector named scores:</div><div>     <font face="Courier New">vector&lt;int&gt; scores;</font></div><div><font face="Courier New"><br></font></div><div>vectors are <i>templated container class</i></div><div>     angle brackets are used to specify the type of the object that will be stored in the vector</div><div><br></div><div><font face="Courier New">push_back</font> is a vector function to append to the end of the vector</div><div>     no corresponding push_front</div><div><br></div><div><font face="Courier New">size</font> - returns the number of items stored in the vector</div><div><br></div><div>after vectors are initialized and filled in, they can be treated just like arrays</div><div>     can be referenced as both l-values and r-values</div><div>     job of the programmer to make sure that the index is within the bounds of the vector</div><div><b><br></b></div><div><b>2.3 Initializing a Vector - The Use of Constructors</b></div><div><b><br></b></div><div>constructs an empty vector of  integers - must be added using <font face="Courier New">push_back</font></div><div>     <font face="Courier New">vector &lt;int&gt; a;</font></div><div><br></div><div>constructs a vector of 100 doubles, each entry storing the value 3.14 - more can be added using <font face="Courier New">push_back</font></div><div>     <font face="Courier New">int n = 100;</font></div><div>     <font face="Courier New">vector&lt;double&gt; b(100, 3.14);</font></div><div><br></div><div>constructs a vector of 10,000 ints, but provides no initial values - more efficient to declare a size at once, for <font face="Courier New">push-back</font></div><div>     <font face="Courier New">push_back</font> will create entry #10,001</div><div>     <font face="Courier New">vector&lt;int&gt; c(n*n);</font></div><div><br></div><div>constructs a vector that is an exact copy of vector b</div><div>     <font face="Courier New">vector&lt;double&gt; d(b);</font></div><div><br></div><div>compiler error, can't change the type stored in a certain vector</div><div>     <font face="Courier New">vector&lt;int&gt; e(b);</font></div><div><b><br></b></div><div><b>2.5 Example: Using Vectors to Compute Standard Deviation</b></div><div><b><br></b></div><div>saved as &quot;std dev.cpp&quot;</div><div><br></div><div><font face="Courier New">#include &lt;fstream&gt;</font></div><div>     file manipulation</div><div><br></div><div>need to include <font face="Courier New">#include &lt;vector&gt;</font> to use vectors</div><div><br></div><div><font face="Courier New">int main(int argc, char* argv[])</font></div><div>     command line arguments</div><div>     argc - how many things are on the command line</div><div>     argv - what those things actually are</div><div><br></div><div><font face="Courier New">while (grades_str &gt;&gt; x)</font></div><div>     returns true as long as there are still lines in the file</div><div>     when file is exhausted, returns false</div><div><br></div><div><b>2.6 Standard Library Sort Function</b></div><div><b><br></b></div><div>std has a series of algorithms to apply to container classes</div><div>     in header file <font face="Courier New">algorithm</font></div><div>     </div><div>provide the beginning and end of the container's interval to sort</div><div><br></div><div>the following code reads, sorts, and outputs a vector of doubles</div><div>     <img src="Lecture 02 - Vectors, Recursion, and Order No_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><font face="Courier New">a.begin()</font> is an iterator referencing the first location in the vector</div><div><font face="Courier New">a.end()</font> references the end</div><div>     every container has iterators</div><div><br></div><div>ordering of values by <font face="Courier New">std::sort</font> is least to greatest</div><div><b><br></b></div><div><b>2.7 Example: Computing the Median</b></div><div><b><br></b></div><div>saved as &quot;median.cpp&quot;</div><div><br></div><div><font face="Courier New">void read_scores(std::vector&lt;int&gt; &amp;scores, std::ifstream &amp;grade_str)</font></div><div>     need to pass as reference if you want to change the actual vector</div><div>     need to pass the file-stream as reference</div><div><br></div><div><font face="Courier New">void compute_avg_and_std_dev(const std::vector&lt;int&gt; &amp;s, double &amp;avg, double &amp;std_dev)</font></div><div>     wasteful to copy unnecessarily</div><div>     rule of thumb: anything &quot;big&quot; and not &quot;simple&quot; - should pass by reference</div><div>          avoid the cost of copy</div><div><br></div><div>     to prevent against mistakes, <font face="Courier New">const</font> identifier is used</div><div><br></div><div><b>2.8 Passing Vectors (and Strings) as Parameters</b></div><div><b><br></b></div><div>if you are passing a vector as a parameter and you want to make a change, you should pass by reference</div><div><br></div><div>should not pass a container object such as a vector or string because of the cost of copying</div><div><br></div><div><b>2.9 Algorithm Analysis</b></div><div><b><br></b></div><div>Why should we bother?</div><div>     want to do better than just implementing and testing every idea we have</div><div>     want to know why one algorithm is better than another</div><div>     want to know the best we can do</div><div><br></div><div>How do we do it?</div><div>     don't do any analysis; just use the first algorithm you can think of that works</div><div>     implement and time algorithms to choose the best</div><div>     analyze by counting operations and assigning &quot;weights&quot; to certain operations</div><div>     analyze by assuming that each operation requires the same amount of time</div><div><br></div><div><b>2.12 Order Notation Definition</b></div><div><b><br></b></div><div>algorithms requiring 3+2n, 14+17n, can be simplified to be O(n) - order n</div><div><br></div><div>determine the order by finding the asympototically dominant term and throwing away the leading constant</div><div>     don't need to quibble about small differences</div><div>     don't need to worry about different costs</div><div>     don't produce an actual time - just a rough count of the number of operations</div><div>     used for comparison purposes</div><div><br></div><div><b>2.13 Common Orders of Magnitude</b></div><div><b><br></b></div><div><img src="Lecture 02 - Vectors, Recursion, and Order No_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>2.19 Recursive C++ Functions</b></div><div><b><br></b></div><div>C++ allows functions to call themselves</div><div><img src="Lecture 02 - Vectors, Recursion, and Order No_files/Image [2].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><b>2.20 The Mechanism of Recursive Function Calls</b></div><div><b><br></b></div><div>for each recursive call, program creates an <i>activation record</i> to keep track of</div><div>     completely separate instances of the parameters</div><div><b><br></b></div><div><img src="Lecture 02 - Vectors, Recursion, and Order No_files/Image [3].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><br></div><div><b>2.23 Rules for Writing Recursive Functions</b></div><div><br></div><div><img src="Lecture 02 - Vectors, Recursion, and Order No_files/Image [4].png" type="image/png" style="cursor: default;cursor: default;"/></div><div><br></div><div><br></div><div><br></div><div><br></div><div><br></div></div>
</div></body></html> 